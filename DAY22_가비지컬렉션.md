

# 가비지 컬렉션

CLR은 자동 메모리 관리( Automatic Memory Management ) 기능을 제공한다. 

가비지 컬렉션 (Garbage Collection) : 쓰레기 수거'라는 뜻으로  더 이상 사용하지 않는 객체를 정리하는 것을 말한다.

가비지 컬렉터 (Garbage Collector) : 가비지 컬렉션을 담당하며, 객체 중에 쓰레기인 것과 아닌 것을 완벽하게 분리해서 쓰레기만 수거해간다.

가비지 컬렉터 역시 소프트웨어이기 때문에 CPU나 메모리와 같은 컴퓨팅 자원을 소모한다. 때문에 프로그램의 성능을 끌어올리기 위해 가비지 컬렉터가 자원을 최소한으로 사용하게 해야 한다.





> **가비지 컬렉터가 치우지 못하는 메모리**
>
> C#으로 작성된 모든 코드는 CLR에 의해 관리되는 관리형코드 ( Managed Code )에 속한다. CLR은 실행되는 코드에 대해 메모리 할당, 보안, 스레딩, 쓰레기 처리등의 일을 책임진다. 
>
> C#으로 비관리형 코드( Unmanaged Code )도 작성할 수 있는데 unsafe 키워드를 사용하면 된다. 이 경우에는 CLR이 제공하는 모든 서비스를 만들 수 없다. 



## 메모리 할당 방법





관리되는 힙을 위한 메모리 공간 확보

관리되는 첫번째 주소에 객체를 할당하게 된다. 그리고 다음으로 이동하게 된다.



## 가비지 컬렉터가 루트 목록을 이용해서 쓰레기 객체를 처리하는 과정

1. 작업을 시작하기 전에, 가비지 컬렉터는 모든 객체가 쓰레기라고 가정한다. ( 루트 목록 내의 어떤 루트도 메모리를 가리키지 않는다고 가정한다. )
2. 루트 목록을 순회하면서 각 루트가 참조하고 있는 힙 객체와의 관계 여부를 조사한다. 만약 루트가 참조하고 있는 힙의 객체가 또 다른 힙의 객체를 참조 하고 있다면 이 역시도 해당 루트와 관계가 있는 것으로 간주한다. 이 때 어던 루트와도 관계가 없는 힙의 객체들은 쓰레기로 간주된다.
3. 쓰레기 객체가 차지하고 있던 메모리를 비운다.
4. 루트 목록에 대한 조사가 끝나면, 가비지 컬렉터는 힙을 순회하면서 쓰레기가 차지하고 있던 '비어있는 공간'에 쓰레기의 인접 객체들을 이동시켜 차곡차곡 채워 넣는다. 





## 세대별 가비지 컬렉션

CLR의 메모리는 구역을 나누어 메모리에서 빨리 사라질 객체와 오래 남아있을 객체를 따로 담아 관리한다.

메모리는 0세대, 1세대, 2세대 세 개의 세대로 나눠진다.

0세대 : 빨리 사라질 것으로 예상되는 객체 - 가비지 컬렉션을 한번도 겪지 않은 '갓 태어난' 객체

1세대 : 0세대에서 2세대로 넘어가는 과도기 객체

2세대 : 오랫동안 살아남을 것으로 예상되는 객체 - 수 차례 가비지 컬렉션을 겪고도 살아남은 객체



### 전체 가비지 컬렉션 ( Full Garbage Collection )

2세대 가비지 컬렉션을 말한다. 2세대 가비지 컬렉션이 시작되면 1세대와 0세대에 대해서도 가비지 컬렉션을 수행하기 때문이다.

0세대에서 가비지 컬렉션이 수행될 때 1세대와 2세대의 가비지 컬렉션을 수행되지 않는다.

1세대에서 가비지 컬렉션이 수행될 때 0세대에서도 가비지 컬렉션이 수행되지만, 2세대에서는 수행되지 않는다.



힙의 각 세대는 0세대 > 1세대 > 2세대 순으로 가비지 컬렉션 빈도가 높다.



2세대가 가득 차게 되면 CLR은 어플리케이션의 실행을 잠시 멈추고 전체 가비지 컬렉션 (Full GC)을 수행한다. 

- CLR에서 애플리케이션 일시 중단
- 0-2세대 전체 메모리에 걸쳐 쓰레기 수집
- 애플리케이션이 차지하는 메모리가 클 수록 Full GC기간이 길어지므로 장시간 실행 중지



## CLR의 가비지 컬렉션의 메커니즘에 근거한, 효울적인 코드작성을 위한 지침



- 객체를 너무 많이 할당하지 않는다.
  - CLR의 객체 할당 속도가 빠르긴하지만 너무 많은 수의 객체는 관리되는 힙의 각 세대에 대하 메모리 포화를 초래하고, 빈번한 가비지 컬렉션을 부르는 결과를 낳는다.
- 너무 큰 객체의 할당을 피한다.
  - CLR은 보통 크기의 객체를 할당하는 힙과는 별도로 85KB 이상의 대형 객체를 할당하기 위한 '대형 객체 힙 ( LOH : Large Object Heap )'을 따로 유지한다. 만약 커다란 객체를 소형 객체 힙( SOH : Small Object Heap) 에 할당한다면 0세대가 빠르게 차오르게 되므로 가비지 컬렉션을 보다 자주 촉발하게 되고, 성능 저하를 가져올 것이다. 
  - 소형 객체 힙은 '다음 객체를 할당할 포인터'가 위치한 메모리에 바로 객체를 할당하지만, 대형 객체 힙은 객체의 크기를 계산한 뒤 그만한 여유 공간이 있는지 힙을 탐색하여 할당한다. 가비지 컬렉션을 수행하고 난 뒤 소형 객체 힙은 해제된 메모리 공간에 인접 객체 들을 끌어당겨 정리하지만, 대형 객체 힙은 해체된 공간을 그대로 둔다 (수MB ~ 수백MB에 이르는 메모리를 복사하는 비용이 크기 때문이다.) . 0바이트도 남김없이 사용하는 소형 객체 힙과 달리 큰 공간을 군데군데 낭비하게 된다. 
  - CLR은 LOH를 2세대 힙으로 간주하기 때문에 LOH에 있는 쓰레기 객체가 수거되려면 2세대에 대한 가비지 컬렉션이 수행되어야 한다. 2세대에 대한 가비지 컬렉션은 전 세대에 대한 가비지 컬렉션을 촉발하고 순간이나마 애플리케이션의 정지를 불러올 수 있다.
- 너무 복잡한 참조 관계는 만들지 않는다.
  - 가비지 컬렉터는 가비지 컬렉션 후에 살아남은 객체의 세대를 옮기기 위해 메모리 복사를 수행한다. 참조 관계가 복잡한 객체의 경우에는 메모리 복사만으로 끝나지 않고 필드간의 참조 관계를 일일히 조사해서 참조하고 있는 메모리 주소를 전부 수정한다.
  - 
- 루트를 너무 많이 만들지 않는다.
  - 가비지 컬렉텨는 루트 목록을 돌면서 쓰레기를 찾아낸다. 루트 목록이 작아진다면  가비지 컬렉처가 수행하는 횟수가 줄어들므로 더 빨리 가비지 컬렉션을 끝낼 수 있다. 





