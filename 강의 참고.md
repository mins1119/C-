콜백

대신 어떤일을 해줄 코드를 두고, 세부실행코드는 컴파일 시점이 아닌 실행시점에 부여

콜백을 구현하는 방법 -> 대리자

대리자는 메소드에 대한 참조

대리자 호출 -> 대리자 -> 메소드 호출

대리자는 형식이므로 인스턴스를 만들고 메소드 참조









람다식

익명메소드를 만드는 또다른 방법



람다식 - 분명하고 간결한 방법으로 함수를 묘사하기위해 표현





람다식으로 만든 익명메소드 =>무명함수



형식유추

식형식과 문형식

식 : a+b, a==b

문형식 : if문



Func, action

매변 별개의 대리자를 선언하기 귀찮으니까

Func = 결과 반환하는 메소드

Action - 결과 반환 x



식트리

트리자료구조

식을 트리로 표햔

부모노드가 단 두개의 자식만 갖는 이진트리

트리의 잎 노드부터 루트까지 올라가면 전체식의 경과



직접 식 트리 조립 및 컴파일해서 사용할 수 있는 기능 제공

동적으로 무명함수를 만들어 사용



Expression 

식트리를 구성하는 노드 표현

파생클래스들의 객체 생성 추상클래스라 인스턴스만들수 업슴



식트리의 실향





리플렉션 코드자체를 데이터로 다루는 기법

객체의 형식 정보를 들여다 보는 기능

프로그램 실행 중에 객체 형식이름부터 여러가지를 볼수 이싿.

형식의 이름이 있다면 동적으로 인스턴스를 망ㄴ들고 인스턴스의 메소드 호출 가능

새로운 데이터 형식을 동적으로 만들수 있따

Gettype .NET에서 사용되는 데이터 형식의 모든 정보 포힘



코드안에서 런타임에 특정 형식의 인스턴스를 만드는 이점

```c#
using System;
using System.Reflection;
using System.Reflection.Emit;

namespace EmitTest_Net
{
    class Program
    {
        static void Main()
        {
            
            AssemblyBuilder newAssembly = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("CalculatorAssembly"), AssemblyBuilderAccess.Run);

            ModuleBuilder newModule = newAssembly.DefineDynamicModule("Calculator");
            TypeBuilder newType = newModule.DefineType("Sum1To100");

            MethodBuilder newMethod = newType.DefineMethod("Calculate", MethodAttributes.Public, typeof(int), new Type[0]);

            ILGenerator generator = newMethod.GetILGenerator();

            generator.Emit(OpCodes.Ldc_I4, 1);

            for (int i = 2; i <= 100; i++)
            {
                generator.Emit(OpCodes.Ldc_I4, i);
                generator.Emit(OpCodes.Add);
            }
            generator.Emit(OpCodes.Ret);
            newType.CreateType();

            object sum1To100 = Activator.CreateInstance(newType);
            MethodInfo Calculate = sum1To100.GetType().GetMethod("Calculate");
            Console.WriteLine(Calculate.Invoke(sum1To100, null));

        }
    }
}
```

어셈블리를 만들어야 하는데 어셈블리 빌드는 생성자가 없어서 팩토리클래스의 도움을 박는다.

system.appdomian 이클래스의 definedynamicassembly메소드를 호출하면 어셈블리를 만들수 있다.

definedynamicmodule메소드로 모듈을 만든다.

definedynamicmodule메소드 메 calculator이름을 전달해서 모듈을 만든다.

ModuleBuilder의DefineType메소드로 클래스를 만든다.

클래스이름을 defineType에 전달

메소드의외관은 typebulder클래스의 definㄷmethod로 만든다

MethodBuilder newMethod = newType.DefineMethod("Calculate"

, MethodAttributes.Public, 

typeof(int), 

new Type[0]);



메소드 내용을 채우는 것은 ILGEnerator객체 사용, GetILgenerator메소드 이용



클래스를 CLR에 제출하기

activator.CrateInstance



어셈블리 모듈 클래스 클래스의 껍데기 만들고 껍데기 안을 채울 IL코드 generation

createtype을 통해 clr에 제출

activatoe.crateInstance를 사용해서 동적으로 생성





애트리뷰트

설명하고자하는 코드앞에 []로 사용



호출자 정보

메소드의 매개변수에 사용됨



ㅣㅣㅏㅣㅏ

